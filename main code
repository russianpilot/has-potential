int sq_s = 8; // Size of Potential_Square
int d = 2;

int s = 52;



int[][] oa = new int[s][s];
float[][] pa = new float[s*d][s*d];

// data logger for point:
int p_x = 21;
int p_y = 26;
float[] tr = new float[1000000]; // einfach mal geraten, dass vorher das feld fertig gerechnet ist

float k = 1; // Potentialdifferenz fürs gesamte Feld
float delta = k;
int counter = 0;

int x_off = 50;
int y_off = 50;

void setup() {
  // x: Main Potential Field: 832 + x_off: 50*2 + Scale: 50
  //   + Evaluation Graph: 1032
  // y: Main Potential Field: 832 + y_off: 50*2  
  size(2014, 1000); 
  background(255);
  colorMode(HSB, 360, 100, 100); // Hue / Saturation / Brightness
  frameRate(240);

  for (int i = 0; i < s*d; i++) {
    for (int j = 0; j < s*d; j++) {
      pa[i][j] = int(random(100));
    }
  }

  for (int i = 0; i < s; i++) {
    for (int j = 0; j < s; j++) {
      oa[i][j] = -1;
    }
  }
  int p_rahmen = 20;
  p_rect(0, 0, 1, 52, p_rahmen);
  p_rect(0, 0, 52, 1, p_rahmen);
  p_rect(0, 51, 52, 1, p_rahmen);
  p_rect(51, 0, 1, 52, p_rahmen);

  p_rect(9, 24, 4, 4, 100);

  //p_rect(25, 6, 1, 40, 0);
  p_rect(41, 24, 4, 4, 0);

  //p_rect(40, 4, 4, 6, 80);
  //p_rect(30, 30, 3, 8, 100);
  //p_rect(36, 30, 3, 8, 20);

  // Skala
  for (int i = 20; i >= 1; i--) {
    fill(map(float(i*5), 0, 100, 240, 60), 100, 100);
    rect(s*d*sq_s+x_off+25, y_off+(s*d*sq_s)/20*(20-i), 25, (s*d*sq_s)/20);
    textSize(15);
    fill(0, 0, 0);
    text(i*5, s*d*sq_s+x_off+55, y_off+(s*d*sq_s)/20*(20-i)+5);
  }
  text(0, s*d*sq_s+x_off+55, y_off+(s*d*sq_s)/20*(20-0)+5);

  // Black Frame
  stroke(255, 0, 0);
  rect(x_off-1, y_off-1, 832+1, 832+1);

  // koordinatenachse fürs feld
  for (int i = 26; i > -27; i--) {
    int l;
    if ( i % 5 == 0) {
      fill(255, 0, 0);
      l = 5;
    } else {
      fill(255, 0, 255);
      l = 0;
    }
    stroke(255, 0, 0);
    line(x_off, y_off+sq_s*d*(26-i), x_off-10-l, y_off+sq_s*d*(26-i));
    text(-i, x_off-45, y_off+sq_s*d*(26-i)+5);
  }
  for (int i = -11; i < 42; i++) {
    int l;
    if ( i % 5 == 0) {
      fill(255, 0, 0);
      l = 5;
    } else {
      fill(255, 0, 255);
      l = 0;
    }
    stroke(255, 0, 0);
    line(x_off+sq_s*d*(i+11), y_off+832, x_off+sq_s*d*(i+11), y_off+832+10+l);
    text(i, x_off+sq_s*d*(i+11)-10, y_off+832+30);
  }


  // Evaluation Graph
  fill(255, 100, 0);
  triangle(170+x_off+832, y_off+10, 180+x_off+832, y_off+10, 175+x_off+832, y_off);
  line(175+x_off+832, y_off, 175+x_off+832, y_off+832);

  triangle(170+x_off+832+832-10, x_off+832-5, 170+x_off+832+832-10, y_off+832+5, 170+x_off+832+832, y_off+832);
  line(170+x_off+832, y_off+832, 170+x_off+832+832, y_off+832);
}

void draw() {

  if ( k <= abs(delta)) {
    println((k<=abs(delta))?"true":"false");
    for (int i = 0; i < s*d-1; i++) {
      for (int j = 0; j < s*d-1; j++) {
        if (oa[int(i/2)][int(j/2)] <= -1) {
          delta += pa[i][j]*1000;
          pa[i][j] = (pa[i-1][j]+pa[i+1][j]+pa[i][j-1]+pa[i][j+1])/4;
          delta -= pa[i][j]*1000;

          // data logger
          if (p_x == i && p_y == j) {
            tr[counter+1] = pa[i][j]-tr[counter];
          }
        }
      }
      counter++;
    }
    delta /= s*d*s*d;

    // Drawing Results
    noStroke();
    for (int i = 0; i < s*d; i++) {
      for (int j = 0; j < s*d; j++) {
        fill(map(pa[i][j], 0, 100, 240, 60), 100, 100);
        rect(i*sq_s+x_off, j*sq_s+y_off, sq_s, sq_s);
      }
    }
    // info Chart Top
    stroke(0, 100, 0);
    fill(0, 0, 100);

    rect(0, 0, 500, 45);
    fill(0, 100, 0);

    text("FPS: ", 5, 20); text(frameRate, 35, 20);
    text("Diff: ", 120, 20); text(abs(delta), 160, 20);
    text("Counter: ", 250, 20); text(counter, 320, 20);
    
    text("Potential ("+ (p_x-11) + "|" + (p_y-26) + "): "+ (pa[p_x][p_y]+pa[p_x+1][p_y]+pa[p_x][p_y+1]+pa[p_x+1][p_y+1])/4, 5, 40);
  }
  else{
    save("field.png");
  }

  noFill();
  stroke(255, 0, 0);
  for (int i = 0; i < s; i++) {
    for (int j = 0; j < s; j++) {
      rect(i*(d*sq_s)+x_off, j*(d*sq_s)+y_off, sq_s*d, sq_s*d);
      //pa[i][j] = int(random(100));
    }
  }
  
  rect(x_off+(p_x*sq_s*d)+1, y_off+(p_y*sq_s*d)+1, d*sq_s, d*sq_s);
}

void p_rect(int x, int y, int xs, int ys, int p) {
  for (int i = x; i < x+xs; i++) {
    for (int j = y; j < y+ys; j++) {
      oa[i][j] = p;
    }
  }

  for (int i = 0; i < s*d; i++) {
    for (int j = 0; j < s*d; j++) {
      if (oa[int(i/2)][int(j/2)] > -1) {
        pa[i][j] = oa[int(i/2)][int(j/2)];
      }
    }
  }
}
